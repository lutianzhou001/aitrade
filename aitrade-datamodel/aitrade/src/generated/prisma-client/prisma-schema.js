module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.27.4). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateBattle {
  count: Int!
}

type AggregateBtcPlaceOrder {
  count: Int!
}

type AggregateCloseout {
  count: Int!
}

type AggregateDistribution {
  count: Int!
}

type AggregateFollow {
  count: Int!
}

type AggregateMoment {
  count: Int!
}

type AggregateMycoin {
  count: Int!
}

type AggregateOnchain {
  count: Int!
}

type AggregateOnchainExchange {
  count: Int!
}

type AggregateRate {
  count: Int!
}

type AggregateSetting {
  count: Int!
}

type AggregateSubscribe {
  count: Int!
}

type AggregateToken {
  count: Int!
}

type AggregateTransactions {
  count: Int!
}

type AggregateUsdtMessage {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateWallet {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Battle {
  longOKex: Int
  shortOKex: Int
  longHuobi: Int
  shortHuobi: Int
  longBitMex: Int
  shortBitMex: Int
}

type BattleConnection {
  pageInfo: PageInfo!
  edges: [BattleEdge]!
  aggregate: AggregateBattle!
}

input BattleCreateInput {
  longOKex: Int
  shortOKex: Int
  longHuobi: Int
  shortHuobi: Int
  longBitMex: Int
  shortBitMex: Int
}

type BattleEdge {
  node: Battle!
  cursor: String!
}

enum BattleOrderByInput {
  longOKex_ASC
  longOKex_DESC
  shortOKex_ASC
  shortOKex_DESC
  longHuobi_ASC
  longHuobi_DESC
  shortHuobi_ASC
  shortHuobi_DESC
  longBitMex_ASC
  longBitMex_DESC
  shortBitMex_ASC
  shortBitMex_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BattlePreviousValues {
  longOKex: Int
  shortOKex: Int
  longHuobi: Int
  shortHuobi: Int
  longBitMex: Int
  shortBitMex: Int
}

type BattleSubscriptionPayload {
  mutation: MutationType!
  node: Battle
  updatedFields: [String!]
  previousValues: BattlePreviousValues
}

input BattleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BattleWhereInput
  AND: [BattleSubscriptionWhereInput!]
  OR: [BattleSubscriptionWhereInput!]
  NOT: [BattleSubscriptionWhereInput!]
}

input BattleUpdateManyMutationInput {
  longOKex: Int
  shortOKex: Int
  longHuobi: Int
  shortHuobi: Int
  longBitMex: Int
  shortBitMex: Int
}

input BattleWhereInput {
  longOKex: Int
  longOKex_not: Int
  longOKex_in: [Int!]
  longOKex_not_in: [Int!]
  longOKex_lt: Int
  longOKex_lte: Int
  longOKex_gt: Int
  longOKex_gte: Int
  shortOKex: Int
  shortOKex_not: Int
  shortOKex_in: [Int!]
  shortOKex_not_in: [Int!]
  shortOKex_lt: Int
  shortOKex_lte: Int
  shortOKex_gt: Int
  shortOKex_gte: Int
  longHuobi: Int
  longHuobi_not: Int
  longHuobi_in: [Int!]
  longHuobi_not_in: [Int!]
  longHuobi_lt: Int
  longHuobi_lte: Int
  longHuobi_gt: Int
  longHuobi_gte: Int
  shortHuobi: Int
  shortHuobi_not: Int
  shortHuobi_in: [Int!]
  shortHuobi_not_in: [Int!]
  shortHuobi_lt: Int
  shortHuobi_lte: Int
  shortHuobi_gt: Int
  shortHuobi_gte: Int
  longBitMex: Int
  longBitMex_not: Int
  longBitMex_in: [Int!]
  longBitMex_not_in: [Int!]
  longBitMex_lt: Int
  longBitMex_lte: Int
  longBitMex_gt: Int
  longBitMex_gte: Int
  shortBitMex: Int
  shortBitMex_not: Int
  shortBitMex_in: [Int!]
  shortBitMex_not_in: [Int!]
  shortBitMex_lt: Int
  shortBitMex_lte: Int
  shortBitMex_gt: Int
  shortBitMex_gte: Int
  AND: [BattleWhereInput!]
  OR: [BattleWhereInput!]
  NOT: [BattleWhereInput!]
}

type BtcPlaceOrder {
  long: Int
  longDeal: Int
  longDealAmount: Int
  short: Int
  shortDeal: Int
  shortDealAmount: Int
}

type BtcPlaceOrderConnection {
  pageInfo: PageInfo!
  edges: [BtcPlaceOrderEdge]!
  aggregate: AggregateBtcPlaceOrder!
}

input BtcPlaceOrderCreateInput {
  long: Int
  longDeal: Int
  longDealAmount: Int
  short: Int
  shortDeal: Int
  shortDealAmount: Int
}

type BtcPlaceOrderEdge {
  node: BtcPlaceOrder!
  cursor: String!
}

enum BtcPlaceOrderOrderByInput {
  long_ASC
  long_DESC
  longDeal_ASC
  longDeal_DESC
  longDealAmount_ASC
  longDealAmount_DESC
  short_ASC
  short_DESC
  shortDeal_ASC
  shortDeal_DESC
  shortDealAmount_ASC
  shortDealAmount_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BtcPlaceOrderPreviousValues {
  long: Int
  longDeal: Int
  longDealAmount: Int
  short: Int
  shortDeal: Int
  shortDealAmount: Int
}

type BtcPlaceOrderSubscriptionPayload {
  mutation: MutationType!
  node: BtcPlaceOrder
  updatedFields: [String!]
  previousValues: BtcPlaceOrderPreviousValues
}

input BtcPlaceOrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BtcPlaceOrderWhereInput
  AND: [BtcPlaceOrderSubscriptionWhereInput!]
  OR: [BtcPlaceOrderSubscriptionWhereInput!]
  NOT: [BtcPlaceOrderSubscriptionWhereInput!]
}

input BtcPlaceOrderUpdateManyMutationInput {
  long: Int
  longDeal: Int
  longDealAmount: Int
  short: Int
  shortDeal: Int
  shortDealAmount: Int
}

input BtcPlaceOrderWhereInput {
  long: Int
  long_not: Int
  long_in: [Int!]
  long_not_in: [Int!]
  long_lt: Int
  long_lte: Int
  long_gt: Int
  long_gte: Int
  longDeal: Int
  longDeal_not: Int
  longDeal_in: [Int!]
  longDeal_not_in: [Int!]
  longDeal_lt: Int
  longDeal_lte: Int
  longDeal_gt: Int
  longDeal_gte: Int
  longDealAmount: Int
  longDealAmount_not: Int
  longDealAmount_in: [Int!]
  longDealAmount_not_in: [Int!]
  longDealAmount_lt: Int
  longDealAmount_lte: Int
  longDealAmount_gt: Int
  longDealAmount_gte: Int
  short: Int
  short_not: Int
  short_in: [Int!]
  short_not_in: [Int!]
  short_lt: Int
  short_lte: Int
  short_gt: Int
  short_gte: Int
  shortDeal: Int
  shortDeal_not: Int
  shortDeal_in: [Int!]
  shortDeal_not_in: [Int!]
  shortDeal_lt: Int
  shortDeal_lte: Int
  shortDeal_gt: Int
  shortDeal_gte: Int
  shortDealAmount: Int
  shortDealAmount_not: Int
  shortDealAmount_in: [Int!]
  shortDealAmount_not_in: [Int!]
  shortDealAmount_lt: Int
  shortDealAmount_lte: Int
  shortDealAmount_gt: Int
  shortDealAmount_gte: Int
  AND: [BtcPlaceOrderWhereInput!]
  OR: [BtcPlaceOrderWhereInput!]
  NOT: [BtcPlaceOrderWhereInput!]
}

type Closeout {
  exchange: String!
  instrument_id: String!
  size: Int!
  created_at: String!
  loss: Float!
  price: Float!
  type: Int!
}

type CloseoutConnection {
  pageInfo: PageInfo!
  edges: [CloseoutEdge]!
  aggregate: AggregateCloseout!
}

input CloseoutCreateInput {
  exchange: String!
  instrument_id: String!
  size: Int!
  created_at: String!
  loss: Float!
  price: Float!
  type: Int!
}

type CloseoutEdge {
  node: Closeout!
  cursor: String!
}

enum CloseoutOrderByInput {
  exchange_ASC
  exchange_DESC
  instrument_id_ASC
  instrument_id_DESC
  size_ASC
  size_DESC
  created_at_ASC
  created_at_DESC
  loss_ASC
  loss_DESC
  price_ASC
  price_DESC
  type_ASC
  type_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CloseoutPreviousValues {
  exchange: String!
  instrument_id: String!
  size: Int!
  created_at: String!
  loss: Float!
  price: Float!
  type: Int!
}

type CloseoutSubscriptionPayload {
  mutation: MutationType!
  node: Closeout
  updatedFields: [String!]
  previousValues: CloseoutPreviousValues
}

input CloseoutSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CloseoutWhereInput
  AND: [CloseoutSubscriptionWhereInput!]
  OR: [CloseoutSubscriptionWhereInput!]
  NOT: [CloseoutSubscriptionWhereInput!]
}

input CloseoutUpdateManyMutationInput {
  exchange: String
  instrument_id: String
  size: Int
  created_at: String
  loss: Float
  price: Float
  type: Int
}

input CloseoutWhereInput {
  exchange: String
  exchange_not: String
  exchange_in: [String!]
  exchange_not_in: [String!]
  exchange_lt: String
  exchange_lte: String
  exchange_gt: String
  exchange_gte: String
  exchange_contains: String
  exchange_not_contains: String
  exchange_starts_with: String
  exchange_not_starts_with: String
  exchange_ends_with: String
  exchange_not_ends_with: String
  instrument_id: String
  instrument_id_not: String
  instrument_id_in: [String!]
  instrument_id_not_in: [String!]
  instrument_id_lt: String
  instrument_id_lte: String
  instrument_id_gt: String
  instrument_id_gte: String
  instrument_id_contains: String
  instrument_id_not_contains: String
  instrument_id_starts_with: String
  instrument_id_not_starts_with: String
  instrument_id_ends_with: String
  instrument_id_not_ends_with: String
  size: Int
  size_not: Int
  size_in: [Int!]
  size_not_in: [Int!]
  size_lt: Int
  size_lte: Int
  size_gt: Int
  size_gte: Int
  created_at: String
  created_at_not: String
  created_at_in: [String!]
  created_at_not_in: [String!]
  created_at_lt: String
  created_at_lte: String
  created_at_gt: String
  created_at_gte: String
  created_at_contains: String
  created_at_not_contains: String
  created_at_starts_with: String
  created_at_not_starts_with: String
  created_at_ends_with: String
  created_at_not_ends_with: String
  loss: Float
  loss_not: Float
  loss_in: [Float!]
  loss_not_in: [Float!]
  loss_lt: Float
  loss_lte: Float
  loss_gt: Float
  loss_gte: Float
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  type: Int
  type_not: Int
  type_in: [Int!]
  type_not_in: [Int!]
  type_lt: Int
  type_lte: Int
  type_gt: Int
  type_gte: Int
  AND: [CloseoutWhereInput!]
  OR: [CloseoutWhereInput!]
  NOT: [CloseoutWhereInput!]
}

scalar DateTime

type Distribution {
  arrange: Int
  count: Int
}

type DistributionConnection {
  pageInfo: PageInfo!
  edges: [DistributionEdge]!
  aggregate: AggregateDistribution!
}

input DistributionCreateInput {
  arrange: Int
  count: Int
}

type DistributionEdge {
  node: Distribution!
  cursor: String!
}

enum DistributionOrderByInput {
  arrange_ASC
  arrange_DESC
  count_ASC
  count_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type DistributionPreviousValues {
  arrange: Int
  count: Int
}

type DistributionSubscriptionPayload {
  mutation: MutationType!
  node: Distribution
  updatedFields: [String!]
  previousValues: DistributionPreviousValues
}

input DistributionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DistributionWhereInput
  AND: [DistributionSubscriptionWhereInput!]
  OR: [DistributionSubscriptionWhereInput!]
  NOT: [DistributionSubscriptionWhereInput!]
}

input DistributionUpdateManyMutationInput {
  arrange: Int
  count: Int
}

input DistributionWhereInput {
  arrange: Int
  arrange_not: Int
  arrange_in: [Int!]
  arrange_not_in: [Int!]
  arrange_lt: Int
  arrange_lte: Int
  arrange_gt: Int
  arrange_gte: Int
  count: Int
  count_not: Int
  count_in: [Int!]
  count_not_in: [Int!]
  count_lt: Int
  count_lte: Int
  count_gt: Int
  count_gte: Int
  AND: [DistributionWhereInput!]
  OR: [DistributionWhereInput!]
  NOT: [DistributionWhereInput!]
}

type Follow {
  follower: String!
  leader: String!
}

type FollowConnection {
  pageInfo: PageInfo!
  edges: [FollowEdge]!
  aggregate: AggregateFollow!
}

input FollowCreateInput {
  follower: String!
  leader: String!
}

type FollowEdge {
  node: Follow!
  cursor: String!
}

enum FollowOrderByInput {
  follower_ASC
  follower_DESC
  leader_ASC
  leader_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FollowPreviousValues {
  follower: String!
  leader: String!
}

type FollowSubscriptionPayload {
  mutation: MutationType!
  node: Follow
  updatedFields: [String!]
  previousValues: FollowPreviousValues
}

input FollowSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FollowWhereInput
  AND: [FollowSubscriptionWhereInput!]
  OR: [FollowSubscriptionWhereInput!]
  NOT: [FollowSubscriptionWhereInput!]
}

input FollowUpdateManyMutationInput {
  follower: String
  leader: String
}

input FollowWhereInput {
  follower: String
  follower_not: String
  follower_in: [String!]
  follower_not_in: [String!]
  follower_lt: String
  follower_lte: String
  follower_gt: String
  follower_gte: String
  follower_contains: String
  follower_not_contains: String
  follower_starts_with: String
  follower_not_starts_with: String
  follower_ends_with: String
  follower_not_ends_with: String
  leader: String
  leader_not: String
  leader_in: [String!]
  leader_not_in: [String!]
  leader_lt: String
  leader_lte: String
  leader_gt: String
  leader_gte: String
  leader_contains: String
  leader_not_contains: String
  leader_starts_with: String
  leader_not_starts_with: String
  leader_ends_with: String
  leader_not_ends_with: String
  AND: [FollowWhereInput!]
  OR: [FollowWhereInput!]
  NOT: [FollowWhereInput!]
}

scalar Long

type Moment {
  user: User
  createdAt: DateTime!
  title: String
  content: String
}

type MomentConnection {
  pageInfo: PageInfo!
  edges: [MomentEdge]!
  aggregate: AggregateMoment!
}

input MomentCreateInput {
  user: UserCreateOneWithoutMomentInput
  title: String
  content: String
}

input MomentCreateOneWithoutUserInput {
  create: MomentCreateWithoutUserInput
}

input MomentCreateWithoutUserInput {
  title: String
  content: String
}

type MomentEdge {
  node: Moment!
  cursor: String!
}

enum MomentOrderByInput {
  createdAt_ASC
  createdAt_DESC
  title_ASC
  title_DESC
  content_ASC
  content_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MomentPreviousValues {
  createdAt: DateTime!
  title: String
  content: String
}

type MomentSubscriptionPayload {
  mutation: MutationType!
  node: Moment
  updatedFields: [String!]
  previousValues: MomentPreviousValues
}

input MomentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MomentWhereInput
  AND: [MomentSubscriptionWhereInput!]
  OR: [MomentSubscriptionWhereInput!]
  NOT: [MomentSubscriptionWhereInput!]
}

input MomentUpdateManyMutationInput {
  title: String
  content: String
}

input MomentUpdateOneWithoutUserInput {
  create: MomentCreateWithoutUserInput
  update: MomentUpdateWithoutUserDataInput
  upsert: MomentUpsertWithoutUserInput
  delete: Boolean
  disconnect: Boolean
}

input MomentUpdateWithoutUserDataInput {
  title: String
  content: String
}

input MomentUpsertWithoutUserInput {
  update: MomentUpdateWithoutUserDataInput!
  create: MomentCreateWithoutUserInput!
}

input MomentWhereInput {
  user: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [MomentWhereInput!]
  OR: [MomentWhereInput!]
  NOT: [MomentWhereInput!]
}

type Mutation {
  createBattle(data: BattleCreateInput!): Battle!
  updateManyBattles(data: BattleUpdateManyMutationInput!, where: BattleWhereInput): BatchPayload!
  deleteManyBattles(where: BattleWhereInput): BatchPayload!
  createBtcPlaceOrder(data: BtcPlaceOrderCreateInput!): BtcPlaceOrder!
  updateManyBtcPlaceOrders(data: BtcPlaceOrderUpdateManyMutationInput!, where: BtcPlaceOrderWhereInput): BatchPayload!
  deleteManyBtcPlaceOrders(where: BtcPlaceOrderWhereInput): BatchPayload!
  createCloseout(data: CloseoutCreateInput!): Closeout!
  updateManyCloseouts(data: CloseoutUpdateManyMutationInput!, where: CloseoutWhereInput): BatchPayload!
  deleteManyCloseouts(where: CloseoutWhereInput): BatchPayload!
  createDistribution(data: DistributionCreateInput!): Distribution!
  updateManyDistributions(data: DistributionUpdateManyMutationInput!, where: DistributionWhereInput): BatchPayload!
  deleteManyDistributions(where: DistributionWhereInput): BatchPayload!
  createFollow(data: FollowCreateInput!): Follow!
  updateManyFollows(data: FollowUpdateManyMutationInput!, where: FollowWhereInput): BatchPayload!
  deleteManyFollows(where: FollowWhereInput): BatchPayload!
  createMoment(data: MomentCreateInput!): Moment!
  updateManyMoments(data: MomentUpdateManyMutationInput!, where: MomentWhereInput): BatchPayload!
  deleteManyMoments(where: MomentWhereInput): BatchPayload!
  createMycoin(data: MycoinCreateInput!): Mycoin!
  updateManyMycoins(data: MycoinUpdateManyMutationInput!, where: MycoinWhereInput): BatchPayload!
  deleteManyMycoins(where: MycoinWhereInput): BatchPayload!
  createOnchain(data: OnchainCreateInput!): Onchain!
  updateManyOnchains(data: OnchainUpdateManyMutationInput!, where: OnchainWhereInput): BatchPayload!
  deleteManyOnchains(where: OnchainWhereInput): BatchPayload!
  createOnchainExchange(data: OnchainExchangeCreateInput!): OnchainExchange!
  updateManyOnchainExchanges(data: OnchainExchangeUpdateManyMutationInput!, where: OnchainExchangeWhereInput): BatchPayload!
  deleteManyOnchainExchanges(where: OnchainExchangeWhereInput): BatchPayload!
  createRate(data: RateCreateInput!): Rate!
  updateRate(data: RateUpdateInput!, where: RateWhereUniqueInput!): Rate
  updateManyRates(data: RateUpdateManyMutationInput!, where: RateWhereInput): BatchPayload!
  upsertRate(where: RateWhereUniqueInput!, create: RateCreateInput!, update: RateUpdateInput!): Rate!
  deleteRate(where: RateWhereUniqueInput!): Rate
  deleteManyRates(where: RateWhereInput): BatchPayload!
  createSetting(data: SettingCreateInput!): Setting!
  updateManySettings(data: SettingUpdateManyMutationInput!, where: SettingWhereInput): BatchPayload!
  deleteManySettings(where: SettingWhereInput): BatchPayload!
  createSubscribe(data: SubscribeCreateInput!): Subscribe!
  updateManySubscribes(data: SubscribeUpdateManyMutationInput!, where: SubscribeWhereInput): BatchPayload!
  deleteManySubscribes(where: SubscribeWhereInput): BatchPayload!
  createToken(data: TokenCreateInput!): Token!
  updateToken(data: TokenUpdateInput!, where: TokenWhereUniqueInput!): Token
  updateManyTokens(data: TokenUpdateManyMutationInput!, where: TokenWhereInput): BatchPayload!
  upsertToken(where: TokenWhereUniqueInput!, create: TokenCreateInput!, update: TokenUpdateInput!): Token!
  deleteToken(where: TokenWhereUniqueInput!): Token
  deleteManyTokens(where: TokenWhereInput): BatchPayload!
  createTransactions(data: TransactionsCreateInput!): Transactions!
  updateManyTransactionses(data: TransactionsUpdateManyMutationInput!, where: TransactionsWhereInput): BatchPayload!
  deleteManyTransactionses(where: TransactionsWhereInput): BatchPayload!
  createUsdtMessage(data: UsdtMessageCreateInput!): UsdtMessage!
  updateManyUsdtMessages(data: UsdtMessageUpdateManyMutationInput!, where: UsdtMessageWhereInput): BatchPayload!
  deleteManyUsdtMessages(where: UsdtMessageWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createWallet(data: WalletCreateInput!): Wallet!
  updateManyWallets(data: WalletUpdateManyMutationInput!, where: WalletWhereInput): BatchPayload!
  deleteManyWallets(where: WalletWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

type Mycoin {
  coin_name: String!
  coin_price: Float!
}

type MycoinConnection {
  pageInfo: PageInfo!
  edges: [MycoinEdge]!
  aggregate: AggregateMycoin!
}

input MycoinCreateInput {
  coin_name: String!
  coin_price: Float!
}

type MycoinEdge {
  node: Mycoin!
  cursor: String!
}

enum MycoinOrderByInput {
  coin_name_ASC
  coin_name_DESC
  coin_price_ASC
  coin_price_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MycoinPreviousValues {
  coin_name: String!
  coin_price: Float!
}

type MycoinSubscriptionPayload {
  mutation: MutationType!
  node: Mycoin
  updatedFields: [String!]
  previousValues: MycoinPreviousValues
}

input MycoinSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MycoinWhereInput
  AND: [MycoinSubscriptionWhereInput!]
  OR: [MycoinSubscriptionWhereInput!]
  NOT: [MycoinSubscriptionWhereInput!]
}

input MycoinUpdateManyMutationInput {
  coin_name: String
  coin_price: Float
}

input MycoinWhereInput {
  coin_name: String
  coin_name_not: String
  coin_name_in: [String!]
  coin_name_not_in: [String!]
  coin_name_lt: String
  coin_name_lte: String
  coin_name_gt: String
  coin_name_gte: String
  coin_name_contains: String
  coin_name_not_contains: String
  coin_name_starts_with: String
  coin_name_not_starts_with: String
  coin_name_ends_with: String
  coin_name_not_ends_with: String
  coin_price: Float
  coin_price_not: Float
  coin_price_in: [Float!]
  coin_price_not_in: [Float!]
  coin_price_lt: Float
  coin_price_lte: Float
  coin_price_gt: Float
  coin_price_gte: Float
  AND: [MycoinWhereInput!]
  OR: [MycoinWhereInput!]
  NOT: [MycoinWhereInput!]
}

interface Node {
  id: ID!
}

type Onchain {
  from: String!
  to: String!
  amount: String!
  timestamp: Int!
}

type OnchainConnection {
  pageInfo: PageInfo!
  edges: [OnchainEdge]!
  aggregate: AggregateOnchain!
}

input OnchainCreateInput {
  from: String!
  to: String!
  amount: String!
  timestamp: Int!
}

type OnchainEdge {
  node: Onchain!
  cursor: String!
}

type OnchainExchange {
  btc: Int
  eth: Int
  usdt: Int
}

type OnchainExchangeConnection {
  pageInfo: PageInfo!
  edges: [OnchainExchangeEdge]!
  aggregate: AggregateOnchainExchange!
}

input OnchainExchangeCreateInput {
  btc: Int
  eth: Int
  usdt: Int
}

type OnchainExchangeEdge {
  node: OnchainExchange!
  cursor: String!
}

enum OnchainExchangeOrderByInput {
  btc_ASC
  btc_DESC
  eth_ASC
  eth_DESC
  usdt_ASC
  usdt_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type OnchainExchangePreviousValues {
  btc: Int
  eth: Int
  usdt: Int
}

type OnchainExchangeSubscriptionPayload {
  mutation: MutationType!
  node: OnchainExchange
  updatedFields: [String!]
  previousValues: OnchainExchangePreviousValues
}

input OnchainExchangeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OnchainExchangeWhereInput
  AND: [OnchainExchangeSubscriptionWhereInput!]
  OR: [OnchainExchangeSubscriptionWhereInput!]
  NOT: [OnchainExchangeSubscriptionWhereInput!]
}

input OnchainExchangeUpdateManyMutationInput {
  btc: Int
  eth: Int
  usdt: Int
}

input OnchainExchangeWhereInput {
  btc: Int
  btc_not: Int
  btc_in: [Int!]
  btc_not_in: [Int!]
  btc_lt: Int
  btc_lte: Int
  btc_gt: Int
  btc_gte: Int
  eth: Int
  eth_not: Int
  eth_in: [Int!]
  eth_not_in: [Int!]
  eth_lt: Int
  eth_lte: Int
  eth_gt: Int
  eth_gte: Int
  usdt: Int
  usdt_not: Int
  usdt_in: [Int!]
  usdt_not_in: [Int!]
  usdt_lt: Int
  usdt_lte: Int
  usdt_gt: Int
  usdt_gte: Int
  AND: [OnchainExchangeWhereInput!]
  OR: [OnchainExchangeWhereInput!]
  NOT: [OnchainExchangeWhereInput!]
}

enum OnchainOrderByInput {
  from_ASC
  from_DESC
  to_ASC
  to_DESC
  amount_ASC
  amount_DESC
  timestamp_ASC
  timestamp_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type OnchainPreviousValues {
  from: String!
  to: String!
  amount: String!
  timestamp: Int!
}

type OnchainSubscriptionPayload {
  mutation: MutationType!
  node: Onchain
  updatedFields: [String!]
  previousValues: OnchainPreviousValues
}

input OnchainSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OnchainWhereInput
  AND: [OnchainSubscriptionWhereInput!]
  OR: [OnchainSubscriptionWhereInput!]
  NOT: [OnchainSubscriptionWhereInput!]
}

input OnchainUpdateManyMutationInput {
  from: String
  to: String
  amount: String
  timestamp: Int
}

input OnchainWhereInput {
  from: String
  from_not: String
  from_in: [String!]
  from_not_in: [String!]
  from_lt: String
  from_lte: String
  from_gt: String
  from_gte: String
  from_contains: String
  from_not_contains: String
  from_starts_with: String
  from_not_starts_with: String
  from_ends_with: String
  from_not_ends_with: String
  to: String
  to_not: String
  to_in: [String!]
  to_not_in: [String!]
  to_lt: String
  to_lte: String
  to_gt: String
  to_gte: String
  to_contains: String
  to_not_contains: String
  to_starts_with: String
  to_not_starts_with: String
  to_ends_with: String
  to_not_ends_with: String
  amount: String
  amount_not: String
  amount_in: [String!]
  amount_not_in: [String!]
  amount_lt: String
  amount_lte: String
  amount_gt: String
  amount_gte: String
  amount_contains: String
  amount_not_contains: String
  amount_starts_with: String
  amount_not_starts_with: String
  amount_ends_with: String
  amount_not_ends_with: String
  timestamp: Int
  timestamp_not: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_gt: Int
  timestamp_gte: Int
  AND: [OnchainWhereInput!]
  OR: [OnchainWhereInput!]
  NOT: [OnchainWhereInput!]
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  battles(where: BattleWhereInput, orderBy: BattleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Battle]!
  battlesConnection(where: BattleWhereInput, orderBy: BattleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BattleConnection!
  btcPlaceOrders(where: BtcPlaceOrderWhereInput, orderBy: BtcPlaceOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BtcPlaceOrder]!
  btcPlaceOrdersConnection(where: BtcPlaceOrderWhereInput, orderBy: BtcPlaceOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BtcPlaceOrderConnection!
  closeouts(where: CloseoutWhereInput, orderBy: CloseoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Closeout]!
  closeoutsConnection(where: CloseoutWhereInput, orderBy: CloseoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CloseoutConnection!
  distributions(where: DistributionWhereInput, orderBy: DistributionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Distribution]!
  distributionsConnection(where: DistributionWhereInput, orderBy: DistributionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DistributionConnection!
  follows(where: FollowWhereInput, orderBy: FollowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Follow]!
  followsConnection(where: FollowWhereInput, orderBy: FollowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FollowConnection!
  moments(where: MomentWhereInput, orderBy: MomentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Moment]!
  momentsConnection(where: MomentWhereInput, orderBy: MomentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MomentConnection!
  mycoins(where: MycoinWhereInput, orderBy: MycoinOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Mycoin]!
  mycoinsConnection(where: MycoinWhereInput, orderBy: MycoinOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MycoinConnection!
  onchains(where: OnchainWhereInput, orderBy: OnchainOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Onchain]!
  onchainsConnection(where: OnchainWhereInput, orderBy: OnchainOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OnchainConnection!
  onchainExchanges(where: OnchainExchangeWhereInput, orderBy: OnchainExchangeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OnchainExchange]!
  onchainExchangesConnection(where: OnchainExchangeWhereInput, orderBy: OnchainExchangeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OnchainExchangeConnection!
  rate(where: RateWhereUniqueInput!): Rate
  rates(where: RateWhereInput, orderBy: RateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Rate]!
  ratesConnection(where: RateWhereInput, orderBy: RateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RateConnection!
  settings(where: SettingWhereInput, orderBy: SettingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Setting]!
  settingsConnection(where: SettingWhereInput, orderBy: SettingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SettingConnection!
  subscribes(where: SubscribeWhereInput, orderBy: SubscribeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Subscribe]!
  subscribesConnection(where: SubscribeWhereInput, orderBy: SubscribeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SubscribeConnection!
  token(where: TokenWhereUniqueInput!): Token
  tokens(where: TokenWhereInput, orderBy: TokenOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Token]!
  tokensConnection(where: TokenWhereInput, orderBy: TokenOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TokenConnection!
  transactionses(where: TransactionsWhereInput, orderBy: TransactionsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Transactions]!
  transactionsesConnection(where: TransactionsWhereInput, orderBy: TransactionsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TransactionsConnection!
  usdtMessages(where: UsdtMessageWhereInput, orderBy: UsdtMessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UsdtMessage]!
  usdtMessagesConnection(where: UsdtMessageWhereInput, orderBy: UsdtMessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UsdtMessageConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  wallets(where: WalletWhereInput, orderBy: WalletOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Wallet]!
  walletsConnection(where: WalletWhereInput, orderBy: WalletOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WalletConnection!
  node(id: ID!): Node
}

type Rate {
  key: String
  value: String
}

type RateConnection {
  pageInfo: PageInfo!
  edges: [RateEdge]!
  aggregate: AggregateRate!
}

input RateCreateInput {
  key: String
  value: String
}

type RateEdge {
  node: Rate!
  cursor: String!
}

enum RateOrderByInput {
  key_ASC
  key_DESC
  value_ASC
  value_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type RatePreviousValues {
  key: String
  value: String
}

type RateSubscriptionPayload {
  mutation: MutationType!
  node: Rate
  updatedFields: [String!]
  previousValues: RatePreviousValues
}

input RateSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RateWhereInput
  AND: [RateSubscriptionWhereInput!]
  OR: [RateSubscriptionWhereInput!]
  NOT: [RateSubscriptionWhereInput!]
}

input RateUpdateInput {
  key: String
  value: String
}

input RateUpdateManyMutationInput {
  key: String
  value: String
}

input RateWhereInput {
  key: String
  key_not: String
  key_in: [String!]
  key_not_in: [String!]
  key_lt: String
  key_lte: String
  key_gt: String
  key_gte: String
  key_contains: String
  key_not_contains: String
  key_starts_with: String
  key_not_starts_with: String
  key_ends_with: String
  key_not_ends_with: String
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  AND: [RateWhereInput!]
  OR: [RateWhereInput!]
  NOT: [RateWhereInput!]
}

input RateWhereUniqueInput {
  key: String
}

type Setting {
  assetsSetting: Int
  positionSetting: Int
  actionSetting: Int
}

type SettingConnection {
  pageInfo: PageInfo!
  edges: [SettingEdge]!
  aggregate: AggregateSetting!
}

input SettingCreateInput {
  assetsSetting: Int
  positionSetting: Int
  actionSetting: Int
}

input SettingCreateOneInput {
  create: SettingCreateInput
}

type SettingEdge {
  node: Setting!
  cursor: String!
}

enum SettingOrderByInput {
  assetsSetting_ASC
  assetsSetting_DESC
  positionSetting_ASC
  positionSetting_DESC
  actionSetting_ASC
  actionSetting_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SettingPreviousValues {
  assetsSetting: Int
  positionSetting: Int
  actionSetting: Int
}

type SettingSubscriptionPayload {
  mutation: MutationType!
  node: Setting
  updatedFields: [String!]
  previousValues: SettingPreviousValues
}

input SettingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SettingWhereInput
  AND: [SettingSubscriptionWhereInput!]
  OR: [SettingSubscriptionWhereInput!]
  NOT: [SettingSubscriptionWhereInput!]
}

input SettingUpdateDataInput {
  assetsSetting: Int
  positionSetting: Int
  actionSetting: Int
}

input SettingUpdateManyMutationInput {
  assetsSetting: Int
  positionSetting: Int
  actionSetting: Int
}

input SettingUpdateOneInput {
  create: SettingCreateInput
  update: SettingUpdateDataInput
  upsert: SettingUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
}

input SettingUpsertNestedInput {
  update: SettingUpdateDataInput!
  create: SettingCreateInput!
}

input SettingWhereInput {
  assetsSetting: Int
  assetsSetting_not: Int
  assetsSetting_in: [Int!]
  assetsSetting_not_in: [Int!]
  assetsSetting_lt: Int
  assetsSetting_lte: Int
  assetsSetting_gt: Int
  assetsSetting_gte: Int
  positionSetting: Int
  positionSetting_not: Int
  positionSetting_in: [Int!]
  positionSetting_not_in: [Int!]
  positionSetting_lt: Int
  positionSetting_lte: Int
  positionSetting_gt: Int
  positionSetting_gte: Int
  actionSetting: Int
  actionSetting_not: Int
  actionSetting_in: [Int!]
  actionSetting_not_in: [Int!]
  actionSetting_lt: Int
  actionSetting_lte: Int
  actionSetting_gt: Int
  actionSetting_gte: Int
  AND: [SettingWhereInput!]
  OR: [SettingWhereInput!]
  NOT: [SettingWhereInput!]
}

type Subscribe {
  follower: String!
  leader: String!
}

type SubscribeConnection {
  pageInfo: PageInfo!
  edges: [SubscribeEdge]!
  aggregate: AggregateSubscribe!
}

input SubscribeCreateInput {
  follower: String!
  leader: String!
}

type SubscribeEdge {
  node: Subscribe!
  cursor: String!
}

enum SubscribeOrderByInput {
  follower_ASC
  follower_DESC
  leader_ASC
  leader_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SubscribePreviousValues {
  follower: String!
  leader: String!
}

type SubscribeSubscriptionPayload {
  mutation: MutationType!
  node: Subscribe
  updatedFields: [String!]
  previousValues: SubscribePreviousValues
}

input SubscribeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SubscribeWhereInput
  AND: [SubscribeSubscriptionWhereInput!]
  OR: [SubscribeSubscriptionWhereInput!]
  NOT: [SubscribeSubscriptionWhereInput!]
}

input SubscribeUpdateManyMutationInput {
  follower: String
  leader: String
}

input SubscribeWhereInput {
  follower: String
  follower_not: String
  follower_in: [String!]
  follower_not_in: [String!]
  follower_lt: String
  follower_lte: String
  follower_gt: String
  follower_gte: String
  follower_contains: String
  follower_not_contains: String
  follower_starts_with: String
  follower_not_starts_with: String
  follower_ends_with: String
  follower_not_ends_with: String
  leader: String
  leader_not: String
  leader_in: [String!]
  leader_not_in: [String!]
  leader_lt: String
  leader_lte: String
  leader_gt: String
  leader_gte: String
  leader_contains: String
  leader_not_contains: String
  leader_starts_with: String
  leader_not_starts_with: String
  leader_ends_with: String
  leader_not_ends_with: String
  AND: [SubscribeWhereInput!]
  OR: [SubscribeWhereInput!]
  NOT: [SubscribeWhereInput!]
}

type Subscription {
  battle(where: BattleSubscriptionWhereInput): BattleSubscriptionPayload
  btcPlaceOrder(where: BtcPlaceOrderSubscriptionWhereInput): BtcPlaceOrderSubscriptionPayload
  closeout(where: CloseoutSubscriptionWhereInput): CloseoutSubscriptionPayload
  distribution(where: DistributionSubscriptionWhereInput): DistributionSubscriptionPayload
  follow(where: FollowSubscriptionWhereInput): FollowSubscriptionPayload
  moment(where: MomentSubscriptionWhereInput): MomentSubscriptionPayload
  mycoin(where: MycoinSubscriptionWhereInput): MycoinSubscriptionPayload
  onchain(where: OnchainSubscriptionWhereInput): OnchainSubscriptionPayload
  onchainExchange(where: OnchainExchangeSubscriptionWhereInput): OnchainExchangeSubscriptionPayload
  rate(where: RateSubscriptionWhereInput): RateSubscriptionPayload
  setting(where: SettingSubscriptionWhereInput): SettingSubscriptionPayload
  subscribe(where: SubscribeSubscriptionWhereInput): SubscribeSubscriptionPayload
  token(where: TokenSubscriptionWhereInput): TokenSubscriptionPayload
  transactions(where: TransactionsSubscriptionWhereInput): TransactionsSubscriptionPayload
  usdtMessage(where: UsdtMessageSubscriptionWhereInput): UsdtMessageSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  wallet(where: WalletSubscriptionWhereInput): WalletSubscriptionPayload
}

type Token {
  tokenID: ID!
  tokenName: String!
  isCopycat: String!
}

type TokenConnection {
  pageInfo: PageInfo!
  edges: [TokenEdge]!
  aggregate: AggregateToken!
}

input TokenCreateInput {
  tokenID: ID!
  tokenName: String!
  isCopycat: String!
}

type TokenEdge {
  node: Token!
  cursor: String!
}

enum TokenOrderByInput {
  tokenID_ASC
  tokenID_DESC
  tokenName_ASC
  tokenName_DESC
  isCopycat_ASC
  isCopycat_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TokenPreviousValues {
  tokenID: ID!
  tokenName: String!
  isCopycat: String!
}

type TokenSubscriptionPayload {
  mutation: MutationType!
  node: Token
  updatedFields: [String!]
  previousValues: TokenPreviousValues
}

input TokenSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TokenWhereInput
  AND: [TokenSubscriptionWhereInput!]
  OR: [TokenSubscriptionWhereInput!]
  NOT: [TokenSubscriptionWhereInput!]
}

input TokenUpdateInput {
  tokenID: ID
  tokenName: String
  isCopycat: String
}

input TokenUpdateManyMutationInput {
  tokenID: ID
  tokenName: String
  isCopycat: String
}

input TokenWhereInput {
  tokenID: ID
  tokenID_not: ID
  tokenID_in: [ID!]
  tokenID_not_in: [ID!]
  tokenID_lt: ID
  tokenID_lte: ID
  tokenID_gt: ID
  tokenID_gte: ID
  tokenID_contains: ID
  tokenID_not_contains: ID
  tokenID_starts_with: ID
  tokenID_not_starts_with: ID
  tokenID_ends_with: ID
  tokenID_not_ends_with: ID
  tokenName: String
  tokenName_not: String
  tokenName_in: [String!]
  tokenName_not_in: [String!]
  tokenName_lt: String
  tokenName_lte: String
  tokenName_gt: String
  tokenName_gte: String
  tokenName_contains: String
  tokenName_not_contains: String
  tokenName_starts_with: String
  tokenName_not_starts_with: String
  tokenName_ends_with: String
  tokenName_not_ends_with: String
  isCopycat: String
  isCopycat_not: String
  isCopycat_in: [String!]
  isCopycat_not_in: [String!]
  isCopycat_lt: String
  isCopycat_lte: String
  isCopycat_gt: String
  isCopycat_gte: String
  isCopycat_contains: String
  isCopycat_not_contains: String
  isCopycat_starts_with: String
  isCopycat_not_starts_with: String
  isCopycat_ends_with: String
  isCopycat_not_ends_with: String
  AND: [TokenWhereInput!]
  OR: [TokenWhereInput!]
  NOT: [TokenWhereInput!]
}

input TokenWhereUniqueInput {
  tokenID: ID
}

type Transactions {
  from: String!
  to: String!
  value: String!
  type: String!
}

type TransactionsConnection {
  pageInfo: PageInfo!
  edges: [TransactionsEdge]!
  aggregate: AggregateTransactions!
}

input TransactionsCreateInput {
  from: String!
  to: String!
  value: String!
  type: String!
}

type TransactionsEdge {
  node: Transactions!
  cursor: String!
}

enum TransactionsOrderByInput {
  from_ASC
  from_DESC
  to_ASC
  to_DESC
  value_ASC
  value_DESC
  type_ASC
  type_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TransactionsPreviousValues {
  from: String!
  to: String!
  value: String!
  type: String!
}

type TransactionsSubscriptionPayload {
  mutation: MutationType!
  node: Transactions
  updatedFields: [String!]
  previousValues: TransactionsPreviousValues
}

input TransactionsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TransactionsWhereInput
  AND: [TransactionsSubscriptionWhereInput!]
  OR: [TransactionsSubscriptionWhereInput!]
  NOT: [TransactionsSubscriptionWhereInput!]
}

input TransactionsUpdateManyMutationInput {
  from: String
  to: String
  value: String
  type: String
}

input TransactionsWhereInput {
  from: String
  from_not: String
  from_in: [String!]
  from_not_in: [String!]
  from_lt: String
  from_lte: String
  from_gt: String
  from_gte: String
  from_contains: String
  from_not_contains: String
  from_starts_with: String
  from_not_starts_with: String
  from_ends_with: String
  from_not_ends_with: String
  to: String
  to_not: String
  to_in: [String!]
  to_not_in: [String!]
  to_lt: String
  to_lte: String
  to_gt: String
  to_gte: String
  to_contains: String
  to_not_contains: String
  to_starts_with: String
  to_not_starts_with: String
  to_ends_with: String
  to_not_ends_with: String
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  AND: [TransactionsWhereInput!]
  OR: [TransactionsWhereInput!]
  NOT: [TransactionsWhereInput!]
}

type UsdtMessage {
  price: Float
  exchangeRate: Float
}

type UsdtMessageConnection {
  pageInfo: PageInfo!
  edges: [UsdtMessageEdge]!
  aggregate: AggregateUsdtMessage!
}

input UsdtMessageCreateInput {
  price: Float
  exchangeRate: Float
}

type UsdtMessageEdge {
  node: UsdtMessage!
  cursor: String!
}

enum UsdtMessageOrderByInput {
  price_ASC
  price_DESC
  exchangeRate_ASC
  exchangeRate_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UsdtMessagePreviousValues {
  price: Float
  exchangeRate: Float
}

type UsdtMessageSubscriptionPayload {
  mutation: MutationType!
  node: UsdtMessage
  updatedFields: [String!]
  previousValues: UsdtMessagePreviousValues
}

input UsdtMessageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UsdtMessageWhereInput
  AND: [UsdtMessageSubscriptionWhereInput!]
  OR: [UsdtMessageSubscriptionWhereInput!]
  NOT: [UsdtMessageSubscriptionWhereInput!]
}

input UsdtMessageUpdateManyMutationInput {
  price: Float
  exchangeRate: Float
}

input UsdtMessageWhereInput {
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  exchangeRate: Float
  exchangeRate_not: Float
  exchangeRate_in: [Float!]
  exchangeRate_not_in: [Float!]
  exchangeRate_lt: Float
  exchangeRate_lte: Float
  exchangeRate_gt: Float
  exchangeRate_gte: Float
  AND: [UsdtMessageWhereInput!]
  OR: [UsdtMessageWhereInput!]
  NOT: [UsdtMessageWhereInput!]
}

type User {
  id: ID!
  createdAt: DateTime!
  phoneNumber: String!
  nickName: String!
  address: String
  introduction: String!
  moment: Moment
  apiKey: String
  apiSecret: String
  passPhrase: String
  subscribeCost: String
  totalProperty: Float
  totalEarnRate: Float
  totalEarnValue: Float
  setting: Setting
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  phoneNumber: String!
  nickName: String!
  address: String
  introduction: String!
  moment: MomentCreateOneWithoutUserInput
  apiKey: String
  apiSecret: String
  passPhrase: String
  subscribeCost: String
  totalProperty: Float
  totalEarnRate: Float
  totalEarnValue: Float
  setting: SettingCreateOneInput
}

input UserCreateOneWithoutMomentInput {
  create: UserCreateWithoutMomentInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutMomentInput {
  phoneNumber: String!
  nickName: String!
  address: String
  introduction: String!
  apiKey: String
  apiSecret: String
  passPhrase: String
  subscribeCost: String
  totalProperty: Float
  totalEarnRate: Float
  totalEarnValue: Float
  setting: SettingCreateOneInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  phoneNumber_ASC
  phoneNumber_DESC
  nickName_ASC
  nickName_DESC
  address_ASC
  address_DESC
  introduction_ASC
  introduction_DESC
  apiKey_ASC
  apiKey_DESC
  apiSecret_ASC
  apiSecret_DESC
  passPhrase_ASC
  passPhrase_DESC
  subscribeCost_ASC
  subscribeCost_DESC
  totalProperty_ASC
  totalProperty_DESC
  totalEarnRate_ASC
  totalEarnRate_DESC
  totalEarnValue_ASC
  totalEarnValue_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  phoneNumber: String!
  nickName: String!
  address: String
  introduction: String!
  apiKey: String
  apiSecret: String
  passPhrase: String
  subscribeCost: String
  totalProperty: Float
  totalEarnRate: Float
  totalEarnValue: Float
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  phoneNumber: String
  nickName: String
  address: String
  introduction: String
  moment: MomentUpdateOneWithoutUserInput
  apiKey: String
  apiSecret: String
  passPhrase: String
  subscribeCost: String
  totalProperty: Float
  totalEarnRate: Float
  totalEarnValue: Float
  setting: SettingUpdateOneInput
}

input UserUpdateManyMutationInput {
  phoneNumber: String
  nickName: String
  address: String
  introduction: String
  apiKey: String
  apiSecret: String
  passPhrase: String
  subscribeCost: String
  totalProperty: Float
  totalEarnRate: Float
  totalEarnValue: Float
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  nickName: String
  nickName_not: String
  nickName_in: [String!]
  nickName_not_in: [String!]
  nickName_lt: String
  nickName_lte: String
  nickName_gt: String
  nickName_gte: String
  nickName_contains: String
  nickName_not_contains: String
  nickName_starts_with: String
  nickName_not_starts_with: String
  nickName_ends_with: String
  nickName_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  introduction: String
  introduction_not: String
  introduction_in: [String!]
  introduction_not_in: [String!]
  introduction_lt: String
  introduction_lte: String
  introduction_gt: String
  introduction_gte: String
  introduction_contains: String
  introduction_not_contains: String
  introduction_starts_with: String
  introduction_not_starts_with: String
  introduction_ends_with: String
  introduction_not_ends_with: String
  moment: MomentWhereInput
  apiKey: String
  apiKey_not: String
  apiKey_in: [String!]
  apiKey_not_in: [String!]
  apiKey_lt: String
  apiKey_lte: String
  apiKey_gt: String
  apiKey_gte: String
  apiKey_contains: String
  apiKey_not_contains: String
  apiKey_starts_with: String
  apiKey_not_starts_with: String
  apiKey_ends_with: String
  apiKey_not_ends_with: String
  apiSecret: String
  apiSecret_not: String
  apiSecret_in: [String!]
  apiSecret_not_in: [String!]
  apiSecret_lt: String
  apiSecret_lte: String
  apiSecret_gt: String
  apiSecret_gte: String
  apiSecret_contains: String
  apiSecret_not_contains: String
  apiSecret_starts_with: String
  apiSecret_not_starts_with: String
  apiSecret_ends_with: String
  apiSecret_not_ends_with: String
  passPhrase: String
  passPhrase_not: String
  passPhrase_in: [String!]
  passPhrase_not_in: [String!]
  passPhrase_lt: String
  passPhrase_lte: String
  passPhrase_gt: String
  passPhrase_gte: String
  passPhrase_contains: String
  passPhrase_not_contains: String
  passPhrase_starts_with: String
  passPhrase_not_starts_with: String
  passPhrase_ends_with: String
  passPhrase_not_ends_with: String
  subscribeCost: String
  subscribeCost_not: String
  subscribeCost_in: [String!]
  subscribeCost_not_in: [String!]
  subscribeCost_lt: String
  subscribeCost_lte: String
  subscribeCost_gt: String
  subscribeCost_gte: String
  subscribeCost_contains: String
  subscribeCost_not_contains: String
  subscribeCost_starts_with: String
  subscribeCost_not_starts_with: String
  subscribeCost_ends_with: String
  subscribeCost_not_ends_with: String
  totalProperty: Float
  totalProperty_not: Float
  totalProperty_in: [Float!]
  totalProperty_not_in: [Float!]
  totalProperty_lt: Float
  totalProperty_lte: Float
  totalProperty_gt: Float
  totalProperty_gte: Float
  totalEarnRate: Float
  totalEarnRate_not: Float
  totalEarnRate_in: [Float!]
  totalEarnRate_not_in: [Float!]
  totalEarnRate_lt: Float
  totalEarnRate_lte: Float
  totalEarnRate_gt: Float
  totalEarnRate_gte: Float
  totalEarnValue: Float
  totalEarnValue_not: Float
  totalEarnValue_in: [Float!]
  totalEarnValue_not_in: [Float!]
  totalEarnValue_lt: Float
  totalEarnValue_lte: Float
  totalEarnValue_gt: Float
  totalEarnValue_gte: Float
  setting: SettingWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}

type Wallet {
  userId: String
  balance: String
}

type WalletConnection {
  pageInfo: PageInfo!
  edges: [WalletEdge]!
  aggregate: AggregateWallet!
}

input WalletCreateInput {
  userId: String
  balance: String
}

type WalletEdge {
  node: Wallet!
  cursor: String!
}

enum WalletOrderByInput {
  userId_ASC
  userId_DESC
  balance_ASC
  balance_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type WalletPreviousValues {
  userId: String
  balance: String
}

type WalletSubscriptionPayload {
  mutation: MutationType!
  node: Wallet
  updatedFields: [String!]
  previousValues: WalletPreviousValues
}

input WalletSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WalletWhereInput
  AND: [WalletSubscriptionWhereInput!]
  OR: [WalletSubscriptionWhereInput!]
  NOT: [WalletSubscriptionWhereInput!]
}

input WalletUpdateManyMutationInput {
  userId: String
  balance: String
}

input WalletWhereInput {
  userId: String
  userId_not: String
  userId_in: [String!]
  userId_not_in: [String!]
  userId_lt: String
  userId_lte: String
  userId_gt: String
  userId_gte: String
  userId_contains: String
  userId_not_contains: String
  userId_starts_with: String
  userId_not_starts_with: String
  userId_ends_with: String
  userId_not_ends_with: String
  balance: String
  balance_not: String
  balance_in: [String!]
  balance_not_in: [String!]
  balance_lt: String
  balance_lte: String
  balance_gt: String
  balance_gte: String
  balance_contains: String
  balance_not_contains: String
  balance_starts_with: String
  balance_not_starts_with: String
  balance_ends_with: String
  balance_not_ends_with: String
  AND: [WalletWhereInput!]
  OR: [WalletWhereInput!]
  NOT: [WalletWhereInput!]
}
`
      }
    